// import { request } from "express";
import User from "../model/user.js";
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import token from "../model/token.js";
dotenv.config();
// this is used to encrypt the data sent in the bosy via an api on the server to the datacase.
// thsts why it is used here as data is sent from here in the form of request.body.

// this file uses the schema created by the user model.
// it creats a newUser objject from the existing user and passes the body of the user data that comes with the request to the newUser object.
// this object creats a schema in the database for signup and stores that data inside the model using save() function of mongoose.
export const signupUser = async(request, response) =>{
    try{
        const salt = await bcrypt.genSalt();
        // this bcrypt.gensalt() function creates a salt.
        // everytime a new and random salt is generated
        // a salt is some random data that is added in front of real data i.e -> ihfwehuffsfaslkdndhi12345.
        const hashedPassword = await bcrypt.hash(request.body.password, salt);
        // everytime a hash is generated....it is random even for same passwords different/random hash is generated.
        // this function bcrypt.hash creates a hashed data of the given password.
        // this hashedpassword is then added to the salt.
        // a salt is some random data that is added in front of hasheddata i.e -> ihfwehuffsfaslkdndhi-hdaodhoie.
        // const user = request.body;

        const user = { username: request.body.username, name: request.body.name, password: hashedPassword};
        const newUser = new User(user);
        // this newUser is an object of the User. i.e. the collection.
        await newUser.save();
        // this saves data in the database.
        return response.status(200).json({msg : 'Signup Successful'});
        // if successful then this.
    }
    catch(error){
        // if not successful then this.
        response.status(500).json({ msg : 'Error While SignUp.'})
    }
}


export const loginUser = async (request,response) => {
    let user = await User.findOne( {username: request.body.username} );
    // this findOne() function finds the existence of the user with the username as provided in the function arguement.
    // if the user exists it returns the 'whole object' from the database.
    if(!user) {
        // if the user with the same username as provided doesnot exists...it returns a 404 status response.
        return response.status(404).json({ msg:'Username doesnot exist!' });
    }
    
    // if the user exists in the database with the same username as provided 
    // password is checked for the user to be same or not!!!.

    try{
        // but the password in the database is stored in the form of hashed data with a salt.
        // and the data password comming from the frontend in the form of request body is unhashed and without any salt.
        let match = await bcrypt.compare(request.body.password, user.password);
        // this function compares the password comming from frontend i.e unhashed given in first argument of the function...with the hashed password
        // comming from the hashed password comming from the database collection named user.

        if (match){
            // the access token expires after a fixed time so a new request for access token is made.
            // access token is generated by adding the body and a secretkey.
            // therefore the function jwt.sign() takes two arguments: ----> the body in json format and a secretkey ----> this key is generated usinng a library crypto.
            // to generate a secretkey using crypto library:
            ////////////////
            //Step 1: use jwt.sign() method;
            //Step 2: go to terminal then write node in the server path eg: 
            //        PS C:\Users\AP\Desktop\Blog\server> node
            // Step 3: write:--->  require('crypto').randomBytes(64).toString('hex').
            // this will give a secretkey add that to .env folder and use it here.
            ///////////////
            // Again use that command for refresh secret key
            //////////////
            const accessToken = jwt.sign(user.toJSON(), process.env.ACCESS_SECRET_KEY, {expiresIn: '15m'} );
            const refreshToken = jwt.sign(user.toJSON(), process.env.REFRESH_SECRT_KEY );
            // this request for new accesstoken is done with the help of a refresh token.

            const newToken = new token( { token: refreshToken } );
            await newToken.save();
            return response.status(200).json({ accessToken: accessToken, refreshToken: refreshToken, name: user.name, username: user.username });

        }
        else{
            return response.status(400).json( { msg: 'Invalid Password' } )
        }
    }
    catch (error) {
        return response.status(500).json({ msg: 'error while loging in the user' });
    }
}